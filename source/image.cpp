#include <SDL_video.h>
#include <SDL_endian.h>
#include <stdio.h>
#include <stdlib.h>
#include "image.h"
#include "video.h"
#include "lodepng.h"
#include "util.h"
#include "list.h"

//#define COLORMAP_FILENAME "data/mmap.col"

#if !defined(SDL_BYTEORDER) || !defined(SDL_BIG_ENDIAN)
#error you should define SDL_BIG_ENDIAN first!
#endif


//static Uint32 colormap[256];	// 共有256种颜色

// Dump of mmap.col
// We don't need to load mmap.col anymore.
static const Uint8 kColormapData[] = {
	0x00, 0x00, 0x00, 0x00, 0xCC, 0xF0, 0xF8, 0x00, 0xA4, 0xE4, 0xF4, 0x00, 0x78, 0xD8, 0xF0, 0x00, 
	0x50, 0xD0, 0xEC, 0x00, 0x28, 0xC8, 0xEC, 0x00, 0x20, 0xB4, 0xE0, 0x00, 0x14, 0x98, 0xC8, 0x00, 
	0x10, 0x80, 0xB4, 0x00, 0x08, 0x68, 0x9C, 0x00, 0x04, 0x54, 0x88, 0x00, 0x00, 0x40, 0x74, 0x00, 
	0x00, 0x30, 0x60, 0x00, 0x00, 0x24, 0x4C, 0x00, 0xB8, 0xB8, 0xFC, 0x00, 0x9C, 0x9C, 0xF8, 0x00, 
	0x84, 0x80, 0xF4, 0x00, 0x6C, 0x68, 0xF0, 0x00, 0x54, 0x50, 0xEC, 0x00, 0x40, 0x38, 0xE8, 0x00, 
	0x2C, 0x20, 0xE8, 0x00, 0x18, 0x14, 0xD8, 0x00, 0x10, 0x08, 0xC4, 0x00, 0x08, 0x04, 0xB0, 0x00, 
	0x04, 0x00, 0x9C, 0x00, 0x04, 0x00, 0x84, 0x00, 0x04, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x50, 0x00, 
	0xA8, 0xF8, 0xFC, 0x00, 0x84, 0xEC, 0xFC, 0x00, 0x60, 0xD8, 0xFC, 0x00, 0x3C, 0xC0, 0xFC, 0x00, 
	0x24, 0xAC, 0xFC, 0x00, 0x10, 0x94, 0xFC, 0x00, 0x00, 0x7C, 0xFC, 0x00, 0x00, 0x58, 0xDC, 0x00, 
	0x00, 0x3C, 0xC0, 0x00, 0x00, 0x24, 0xA4, 0x00, 0x00, 0x10, 0x84, 0x00, 0x00, 0x04, 0x68, 0x00, 
	0x00, 0x00, 0x4C, 0x00, 0x84, 0xF4, 0xF4, 0x00, 0x64, 0xDC, 0xDC, 0x00, 0x34, 0xC8, 0xC8, 0x00, 
	0x10, 0xB4, 0xB4, 0x00, 0x04, 0x9C, 0x9C, 0x00, 0x00, 0x88, 0x88, 0x00, 0x6C, 0xE4, 0x88, 0x00, 
	0x58, 0xD0, 0x78, 0x00, 0x48, 0xC0, 0x6C, 0x00, 0x40, 0xB0, 0x60, 0x00, 0x34, 0xA4, 0x54, 0x00, 
	0x30, 0x98, 0x48, 0x00, 0x24, 0x88, 0x38, 0x00, 0x18, 0x78, 0x28, 0x00, 0x10, 0x68, 0x1C, 0x00, 
	0x08, 0x58, 0x14, 0x00, 0x04, 0x48, 0x08, 0x00, 0x00, 0x38, 0x04, 0x00, 0x00, 0x28, 0x00, 0x00, 
	0x00, 0x18, 0x00, 0x00, 0xF8, 0xD4, 0xD4, 0x00, 0xF8, 0xC0, 0xC0, 0x00, 0xF8, 0xAC, 0xAC, 0x00, 
	0xF8, 0x98, 0x98, 0x00, 0xF8, 0x84, 0x84, 0x00, 0xF8, 0x70, 0x70, 0x00, 0xF8, 0x5C, 0x5C, 0x00, 
	0xF8, 0x48, 0x48, 0x00, 0xFC, 0x34, 0x34, 0x00, 0xFC, 0x20, 0x20, 0x00, 0xD8, 0x14, 0x14, 0x00, 
	0xB8, 0x0C, 0x0C, 0x00, 0x98, 0x04, 0x04, 0x00, 0x74, 0x04, 0x04, 0x00, 0x54, 0x00, 0x00, 0x00, 
	0x34, 0x00, 0x00, 0x00, 0xE8, 0xC8, 0xE8, 0x00, 0xD0, 0x98, 0xD0, 0x00, 0xBC, 0x6C, 0xBC, 0x00, 
	0xA8, 0x4C, 0xA8, 0x00, 0x94, 0x2C, 0x94, 0x00, 0x80, 0x14, 0x80, 0x00, 0x70, 0x0C, 0x70, 0x00, 
	0x60, 0x04, 0x60, 0x00, 0x50, 0x00, 0x50, 0x00, 0x44, 0x00, 0x44, 0x00, 0xC0, 0xCC, 0xE4, 0x00, 
	0xA4, 0xB4, 0xD8, 0x00, 0x8C, 0xA0, 0xCC, 0x00, 0x74, 0x8C, 0xC4, 0x00, 0x68, 0x80, 0xB0, 0x00, 
	0x5C, 0x74, 0x9C, 0x00, 0x50, 0x68, 0x88, 0x00, 0x44, 0x5C, 0x78, 0x00, 0x38, 0x4C, 0x64, 0x00, 
	0x2C, 0x40, 0x50, 0x00, 0x24, 0x30, 0x3C, 0x00, 0x18, 0x24, 0x2C, 0x00, 0xEC, 0xEC, 0xEC, 0x00, 
	0xDC, 0xDC, 0xDC, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0xBC, 0xBC, 0xBC, 0x00, 0xAC, 0xAC, 0xAC, 0x00, 
	0x9C, 0x9C, 0x9C, 0x00, 0x8C, 0x8C, 0x8C, 0x00, 0x7C, 0x7C, 0x7C, 0x00, 0x6C, 0x6C, 0x6C, 0x00, 
	0x60, 0x60, 0x60, 0x00, 0x50, 0x50, 0x50, 0x00, 0x44, 0x44, 0x44, 0x00, 0x34, 0x34, 0x34, 0x00, 
	0x24, 0x24, 0x24, 0x00, 0x18, 0x18, 0x18, 0x00, 0x0C, 0x0C, 0x0C, 0x00, 0xE4, 0xE8, 0xEC, 0x00, 
	0xD0, 0xD4, 0xDC, 0x00, 0xBC, 0xC4, 0xCC, 0x00, 0xAC, 0xB0, 0xBC, 0x00, 0x98, 0xA0, 0xAC, 0x00, 
	0x88, 0x90, 0x9C, 0x00, 0x78, 0x80, 0x8C, 0x00, 0x68, 0x70, 0x7C, 0x00, 0x5C, 0x60, 0x6C, 0x00, 
	0x50, 0x54, 0x60, 0x00, 0x44, 0x48, 0x50, 0x00, 0x38, 0x3C, 0x44, 0x00, 0x2C, 0x2C, 0x34, 0x00, 
	0x20, 0x20, 0x24, 0x00, 0x14, 0x14, 0x18, 0x00, 0xC8, 0xE0, 0xFC, 0x00, 0xA4, 0xC4, 0xEC, 0x00, 
	0x80, 0xA8, 0xDC, 0x00, 0x64, 0x90, 0xCC, 0x00, 0x48, 0x78, 0xBC, 0x00, 0x30, 0x60, 0xAC, 0x00, 
	0x1C, 0x4C, 0x9C, 0x00, 0x08, 0x3C, 0x8C, 0x00, 0x00, 0x2C, 0x7C, 0x00, 0x00, 0x24, 0x6C, 0x00, 
	0x00, 0x1C, 0x5C, 0x00, 0x00, 0x14, 0x4C, 0x00, 0x00, 0x0C, 0x3C, 0x00, 0x00, 0x08, 0x2C, 0x00, 
	0x00, 0x04, 0x20, 0x00, 0xF8, 0xE0, 0x94, 0x00, 0xF4, 0xD4, 0x80, 0x00, 0xE8, 0xC0, 0x68, 0x00, 
	0xE0, 0xB0, 0x54, 0x00, 0xCC, 0x98, 0x40, 0x00, 0xB8, 0x84, 0x30, 0x00, 0xA4, 0x70, 0x24, 0x00, 
	0x00, 0xD0, 0x84, 0x00, 0x00, 0xB0, 0x84, 0x00, 0x00, 0x94, 0x7C, 0x00, 0x00, 0x78, 0x68, 0x00, 
	0x00, 0x58, 0x50, 0x00, 0x00, 0x40, 0x44, 0x00, 0x00, 0x28, 0x30, 0x00, 0x00, 0x18, 0x20, 0x00, 
	0xB4, 0xC0, 0xDC, 0x00, 0xA0, 0xB4, 0xCC, 0x00, 0x94, 0x9C, 0xBC, 0x00, 0x80, 0x90, 0xAC, 0x00, 
	0x70, 0x80, 0x9C, 0x00, 0x64, 0x70, 0x8C, 0x00, 0x58, 0x60, 0x80, 0x00, 0x4C, 0x54, 0x70, 0x00, 
	0x40, 0x44, 0x60, 0x00, 0x34, 0x38, 0x50, 0x00, 0x28, 0x2C, 0x44, 0x00, 0x1C, 0x20, 0x34, 0x00, 
	0x14, 0x14, 0x24, 0x00, 0x0C, 0x0C, 0x18, 0x00, 0xD4, 0xE8, 0xE0, 0x00, 0xAC, 0xD8, 0xCC, 0x00, 
	0x98, 0xC8, 0xBC, 0x00, 0x88, 0xB8, 0xAC, 0x00, 0x74, 0xA8, 0x9C, 0x00, 0x64, 0x98, 0x8C, 0x00, 
	0x54, 0x88, 0x7C, 0x00, 0x44, 0x78, 0x6C, 0x00, 0x38, 0x68, 0x60, 0x00, 0x2C, 0x58, 0x50, 0x00, 
	0x20, 0x48, 0x40, 0x00, 0x18, 0x38, 0x34, 0x00, 0x10, 0x2C, 0x24, 0x00, 0x08, 0x1C, 0x18, 0x00, 
	0xB4, 0xD0, 0xD8, 0x00, 0x88, 0xB0, 0xC4, 0x00, 0x78, 0xA8, 0xBC, 0x00, 0x68, 0x9C, 0xB8, 0x00, 
	0x50, 0x88, 0xA8, 0x00, 0x3C, 0x74, 0x9C, 0x00, 0x2C, 0x64, 0x90, 0x00, 0x20, 0x54, 0x84, 0x00, 
	0x14, 0x48, 0x78, 0x00, 0x0C, 0x3C, 0x68, 0x00, 0x08, 0x30, 0x5C, 0x00, 0x04, 0x28, 0x50, 0x00, 
	0x04, 0x1C, 0x40, 0x00, 0x00, 0x14, 0x34, 0x00, 0x00, 0x0C, 0x28, 0x00, 0x00, 0x0C, 0x1C, 0x00, 
	0xC0, 0xD4, 0xFC, 0x00, 0xB0, 0xC8, 0xFC, 0x00, 0xA0, 0xC0, 0xFC, 0x00, 0x90, 0xB4, 0xFC, 0x00, 
	0x80, 0xAC, 0xFC, 0x00, 0x70, 0xA4, 0xFC, 0x00, 0x60, 0x9C, 0xFC, 0x00, 0x54, 0x90, 0xEC, 0x00, 
	0x4C, 0x84, 0xDC, 0x00, 0x44, 0x78, 0xD0, 0x00, 0x3C, 0x6C, 0xC0, 0x00, 0x34, 0x64, 0xB4, 0x00, 
	0x2C, 0x58, 0xA4, 0x00, 0x28, 0x50, 0x98, 0x00, 0x64, 0x8C, 0x98, 0x00, 0x58, 0x78, 0x88, 0x00, 
	0x4C, 0x64, 0x78, 0x00, 0x40, 0x54, 0x68, 0x00, 0x34, 0x44, 0x58, 0x00, 0x2C, 0x38, 0x50, 0x00, 
	0xF0, 0xD4, 0xB0, 0x00, 0xF8, 0xF0, 0xE4, 0x00, 0xF0, 0xD4, 0xB0, 0x00, 0xE4, 0xAC, 0x70, 0x00, 
	0xD8, 0x8C, 0x34, 0x00, 0xD0, 0x6C, 0x00, 0x00, 0xD8, 0x8C, 0x30, 0x00, 0xE4, 0xB0, 0x6C, 0x00, 
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 
	0x9C, 0x98, 0xFC, 0x00, 0x54, 0xE8, 0xFC, 0x00, 0x54, 0x58, 0xFC, 0x00, 0x28, 0x14, 0xDC, 0x00, 
	0x5C, 0xAC, 0xFC, 0x00, 0x1C, 0x8C, 0xFC, 0x00, 0x4C, 0x38, 0xFC, 0x00, 0x1C, 0x0C, 0xC0, 0x00, 
	0x34, 0x1C, 0xFC, 0x00, 0xC0, 0x78, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 
};


static const Uint32 *colormap = (Uint32 *)kColormapData;


#if 0
Surface::pointer Image_LoadPNG2(const char *filename)
{
    Uint32 rmask, gmask, bmask, amask;
    Uint8 *png;
#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000;
	gmask = 0x00ff0000;
	bmask = 0x0000ff00;
	amask = 0x000000ff;
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
	amask = 0xff000000;
#endif
    unsigned int width=0, height=0;
    MemoryBlock mem;
    mem.create(filename);
    unsigned error = lodepng_decode32(&png, &width, &height, (Uint8*)mem.ptr(), mem.getSize());
    if (error) {
        Log("LoadPNG failed.");
        //return Surface::shared_ptr();
        return Surface::pointer();
    }
    //Surface::shared_ptr surf(new Surface());
    Surface::pointer surf(new Surface());
    surf->createFrom(png, width, height, 32, width*4, rmask, gmask, bmask, amask);
}
#endif


SDL_Surface *Image_LoadPNG(const char *filename)
{
	SDL_Surface *img = NULL;
	SDL_Surface *ret = NULL;
	unsigned width = 0, height = 0;
	Uint8 *png = NULL;
	unsigned error = 0;
    MemoryBlock mem;
	unsigned rmask, gmask, bmask, amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000;
	gmask = 0x00ff0000;
	bmask = 0x0000ff00;
	amask = 0x000000ff;
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
	amask = 0xff000000;
#endif
    mem.create(filename);
	error = lodepng_decode32(&png, &width, &height, (Uint8 *)mem.ptr(), mem.size());
	if (error) {
		DLOG("failed!");
		return NULL;
	}
	img = SDL_CreateRGBSurfaceFrom(png, width, height, 32, width * 4, 
            rmask, gmask, bmask, amask);
	if (!img) {
		DLOG("cannot create surface");
		free(png);
	}
	ret = SDL_ConvertSurface(img, Video_GetCanvas()->format, SDL_SWSURFACE);
	if (!ret) {
		DLOG("cannot create surface");
	}
	SDL_FreeSurface(img);
	free(png);
	return ret;
}


SDL_Surface *Image_LoadJYBMP_Mem(Uint8 *data, int w, int h, int datalen)
{
	int p = 0;
	int i, j;
	int yoffset;
	int row;
	int start;
	int x;
	int solidnum;
	SDL_Surface *ps1, *ps2;
    MemoryBlock pixels;

	static bool colormap_loaded = false;

	if (!colormap_loaded) {
		//LoadColorMap(COLORMAP_FILENAME);
		colormap_loaded = true;
	}

	//pixels = (Uint32 *) Util_malloc(w * h * 4);
    pixels.create(w * h * 4);
    Uint32 *ptr = (Uint32 *)pixels.ptr();
	for (i = 0; i < w * h; i++)
		ptr[i] = COLOR_KEY;
	for (i = 0; i < h; i++) {
		yoffset = i * w;
		row = data[p];			// i行数据个数
		start = p;
		p++;
		if (row > 0) {
			x = 0;				// i行目前列
			for (;;) {
				x = x + data[p];	// i行空白点个数，跳个透明点
				if (x >= w)		// i行宽度到头，结束
					break;
				p++;
				solidnum = data[p];	// 不透明点个数
				p++;
				for (j = 0; j < solidnum; j++) {
					ptr[yoffset + x] = colormap[data[p]];
					p++;
					x++;
				}
				if (x >= w)
					break;		// i行宽度到头，结束
				if (p - start >= row)
					break;		// i行没有数据，结束
			}
			if (p + 1 >= datalen)
				break;
		}
	}
	//创建32位表面
	ps1 = SDL_CreateRGBSurfaceFrom(ptr, w, h, 32, w * 4, 0xff0000, 0xff00, 0xff, 0);
	if (ps1 == NULL) {
		DLOG("cannot create surface!");
		//Util_free(pixels);
		return NULL;
	}
	//ps2=SDL_DisplayFormat(ps1);   // 把32位表面改为当前表面
	ps2 = SDL_ConvertSurface(ps1, Video_GetCanvas()->format, SDL_SWSURFACE);
	if (ps2 == NULL) {
		DLOG("cannot create surface!");
	}
	SDL_FreeSurface(ps1);
	//Util_free(pixels);
	//SDL_SetColorKey(ps2, SDL_SRCCOLORKEY|SDL_RLEACCEL, ConvertColor(COLOR_KEY));  //透明色
	SDL_SetColorKey(ps2, true, ConvertColor(COLOR_KEY));
	return ps2;
}

SDL_Surface *Image_LoadPNG_Mem(Uint8 * data, size_t len)
{
	unsigned error = 0;
	unsigned width = 0;
	unsigned height = 0;
	Uint8 *png = NULL;
	SDL_Surface *img = NULL;
	SDL_Surface *ret = NULL;
	unsigned rmask, gmask, bmask, amask;


#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000;
	gmask = 0x00ff0000;
	bmask = 0x0000ff00;
	amask = 0x000000ff;
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
	amask = 0xff000000;
#endif

	error = lodepng_decode32(&png, &width, &height, data, len);
	if (error) {
		DLOG("error decoding png!");
		return NULL;
	}
	img = SDL_CreateRGBSurfaceFrom(png, width, height, 32, width * 4, 
            rmask, gmask, bmask, amask);
	if (!img) {
		DLOG("cannot create surface!");
		free(png);
	}
	ret = SDL_ConvertSurface(img, Video_GetCanvas()->format, SDL_SWSURFACE);
	if (!ret) {
		DLOG("cannot create surface!");
		free(png);
	}
	SDL_FreeSurface(img);
	free(png);
	return ret;
}


bool Image_IsPNG_Mem(Uint8 *p)
{
	return (p[0] == 0x89 && p[1] == 'P' && p[2] == 'N' && p[3] == 'G');
}

/**
 * JY_LoadPicture
 * 加载图形文件，其他格式也可以加载
 * x,y =-1 则加载到屏幕中心
 * 如果未加载，则加载，然后blit，如果加载，直接blit
 * str 文件名，如果为空，则释放表面
 */

int JY_DrawImage(const char *filename, int x, int y)
{
	SDL_Surface *surface = NULL;
	SDL_Rect rect;

	if (strlen(filename) == 0)
		return 0;

	surface = Image_LoadPNG(filename);
	if (!surface) {
		Log("cannot load file %s", filename);
		return 1;
	}
	if (x == -1 && y == -1) {
		x = (Video_GetScreenWidth() - surface->w) / 2;
		y = (Video_GetScreenHeight() - surface->h) / 2;
	}
	rect.x = (Sint16) x;
	rect.y = (Sint16) y;
	SDL_BlitSurface(surface, NULL, Video_GetCanvas(), &rect);
	SDL_FreeSurface(surface);
	return 0;
}

// 读取idx/grp的贴图文件。
// 为提高速度，采用缓存方式读取。把idx/grp读入内存，然后定义若干个缓存表面
// 经常访问的pic放在缓存表面中

// 定义使用的链表 
//贴图cache链表节点e
typedef struct SCacheNode
{
	SDL_Surface *s;				// 此贴图对应的表面
	int xoff;					// 贴图偏移
	int yoff;
	int id;						//贴图编号
	int fileid;					//贴图文件编号
	struct list_head list;		// 链表结构，linux.h中的list.h中定义
} TCacheNode;

//贴图文件链表节点
typedef struct SPicFileCache
{
	int num;					// 文件贴图个数
	int *idx;					// idx的内容
	int filelength;				//grp文件长度
	//FILE *fp;					//grp文件句柄
    SDL_RWops *rw;
	unsigned char *grp;			// grp的内容
	TCacheNode **pcache;		// 文件中所有的贴图对应的cache节点指针，为空则表示没有。
} TPicFileCache;

#define 				PIC_FILE_NUM 40	//缓存的贴图文件(idx/grp)个数
static TPicFileCache pic_file[PIC_FILE_NUM];
LIST_HEAD(cache_head);			//定义cache链表头

static int s_current_cache_num = 0;	// 当前使用的cache数
static int g_MAXCacheNum = 1000;	// 最大Cache个数
static int s_caching_fail_count = 0;

// 初始化Cache数据。游戏开始时调用
int Init_Cache()
{
	int i;
	for (i = 0; i < PIC_FILE_NUM; i++) {
		pic_file[i].num = 0;
		pic_file[i].idx = NULL;
		pic_file[i].grp = NULL;
		//pic_file[i].fp = NULL;
        pic_file[i].rw = NULL;
		pic_file[i].pcache = NULL;
	}
	return 0;
}



// 初始化贴图cache信息
// paletteFilename 为256调色板文件。第一次调用时载入
// 为空字符串则表示重新清空贴图cache信息。在主地图/场景/战斗切换时调用
int JY_PicInit(void)
{

	struct list_head *pos, *p;
	int i;

	//LoadColorMap(paletteFilename);   //载入调色板

	//如果链表不为空，删除全部链表
	list_for_each_safe(pos, p, &cache_head) {
		TCacheNode *tmp = list_entry(pos, TCacheNode, list);
		if (tmp->s != NULL)
			SDL_FreeSurface(tmp->s);	//删除表面
		list_del(pos);
		Util_free(tmp);
	}

	for (i = 0; i < PIC_FILE_NUM; i++) {
		pic_file[i].num = 0;
		Util_free(pic_file[i].idx);
		Util_free(pic_file[i].grp);
		Util_free(pic_file[i].pcache);
//		if (pic_file[i].fp) {
//			fclose(pic_file[i].fp);
//			pic_file[i].fp = NULL;
//		}
	}

	s_current_cache_num = 0;
	s_caching_fail_count = 0;
	return 0;
}

// 加载文件信息
// filename 文件名 
// id  0 - PIC_FILE_NUM-1
int JY_PicLoadFile(const char *idxfilename, const char *grpfilename, int id)
{
	int i;
	TCacheNode *tmpcache;
    RWops file;

	// id超出范围
	if (id < 0 || id >= PIC_FILE_NUM) {
		return 1;
	}
	//释放当前文件占用的空间，并清理cache
	if (pic_file[id].pcache) {
		int i;
		for (i = 0; i < pic_file[id].num; i++) {	//循环全部贴图，
			tmpcache = pic_file[id].pcache[i];
			// 该贴图有缓存则删除
			if (tmpcache) {
				if (tmpcache->s != NULL)
					SDL_FreeSurface(tmpcache->s);	//删除表面
				list_del(&tmpcache->list);	//删除链表
				Util_free(tmpcache);	//释放cache内存
				s_current_cache_num--;
			}
		}
		Util_free(pic_file[id].pcache);
	}
	Util_free(pic_file[id].idx);
	Util_free(pic_file[id].grp);
//	if (pic_file[id].fp) {
//		fclose(pic_file[id].fp);
//		pic_file[id].fp = NULL;
//	}
	// 读取idx文件

    file.fromFile(idxfilename, "r");
	//pic_file[id].num = Util_GetFileLength(idxfilename) / 4;	//idx 贴图个数
	pic_file[id].num = file.getLength() / 4;
	pic_file[id].idx = (int *) Util_malloc((pic_file[id].num + 1) * 4);
	//读取贴图idx文件
	//rw = SDL_RWFromFile(idxfilename, "r");
    file.read(&pic_file[id].idx[1], 4, pic_file[id].num);
    file.close();

	pic_file[id].idx[0] = 0;
	//读取grp文件
    file.fromFile(grpfilename, "r");
	//pic_file[id].filelength = Util_GetFileLength(grpfilename);
	pic_file[id].filelength = file.getLength();

	pic_file[id].grp = (unsigned char *) Util_malloc(pic_file[id].filelength);

    file.read(pic_file[id].grp, 1, pic_file[id].filelength);
    file.close();

	pic_file[id].pcache = (TCacheNode **) Util_malloc(pic_file[id].num * sizeof(TCacheNode *));
	for (i = 0; i < pic_file[id].num; i++)
		pic_file[id].pcache[i] = NULL;

	return 0;
}


// 加载贴图到表面
static int LoadPic(int fileid, int picid, TCacheNode * cache)
{

    RWops file;
	int id1, id2;
	int datalong;
	unsigned char *p, *data;
	SDL_Surface *tmpsurf = NULL;

	if (pic_file[fileid].idx == NULL) {
		DLOG(va("cannot load, fileid=%d", fileid));
		return 1;
	}
	id1 = pic_file[fileid].idx[picid];
	id2 = pic_file[fileid].idx[picid + 1];


	// 处理一些特殊情况，按照修改器中的代码
	if (id1 < 0)
		datalong = 0;

	if (id2 > pic_file[fileid].filelength)
		id2 = pic_file[fileid].filelength;

	datalong = id2 - id1;

	if (datalong > 0) {
		//读取贴图grp文件，得到原始数据   
		data = pic_file[fileid].grp + id1;
		p = NULL;

        file.fromMem(data, datalong);

		if (!Image_IsPNG_Mem(data)) {
			int w, h;
			w = *(short *) data;
			h = *(short *) (data + 2);
			cache->xoff = *(short *) (data + 4);
			cache->yoff = *(short *) (data + 6);
			cache->s = Image_LoadJYBMP_Mem(data + 8, w, h, datalong - 8);

		} else {
			//读取png格式
			tmpsurf = Image_LoadPNG_Mem(data, datalong);
			if (tmpsurf == NULL) {
				DLOG("cannot create SDL_Surface tmpsurf!");
			}
			cache->xoff = tmpsurf->w / 2;
			cache->yoff = tmpsurf->h / 2;
			cache->s = tmpsurf;
		}
        file.close();
		Util_free(p);
	} else {
		cache->s = NULL;
		cache->xoff = 0;
		cache->yoff = 0;
	}
	return 0;
}

// 加载并显示贴图
// fileid        贴图文件id 
// picid     贴图编号
// x,y       显示位置
//  flag 不同bit代表不同含义，缺省均为0
//  B0    0 考虑偏移xoff，yoff。=1 不考虑偏移量
//  B1    0     , 1 与背景alpla 混合显示, value 为alpha值(0-256), 0表示透明
//  B2            1 全黑
//  B3            1 全白
//  value 按照flag定义，为alpha值， 



int Image_DrawCachedImage(int fileid, int picid, int x, int y, int flag, int value)
//int Image_DrawCachedImage(int fileid, int picid, int x, int y, int flag, int value)
{
	TCacheNode *newcache, *tmpcache;
	int xnew, ynew;

	picid = picid / 2;

	if (fileid < 0 || fileid >= PIC_FILE_NUM || picid < 0 || picid >= pic_file[fileid].num)
		return 1;
	//当前贴图没有加载
	if (pic_file[fileid].pcache[picid] == NULL) {
		//生成cache数据
		newcache = (TCacheNode *)Util_malloc(sizeof(TCacheNode));
		if (newcache == NULL) {
			DLOG("out of memory");
			return 1;
		}

		newcache->id = picid;
		newcache->fileid = fileid;
		LoadPic(fileid, picid, newcache);

		pic_file[fileid].pcache[picid] = newcache;
		//cache没满
		if (s_current_cache_num < g_MAXCacheNum) {
			list_add(&newcache->list, &cache_head);	//加载到表头
			s_current_cache_num++;
		}
		//cache 已满
		else {
			tmpcache = list_entry(cache_head.prev, TCacheNode, list);	//最后一个cache
			pic_file[tmpcache->fileid].pcache[tmpcache->id] = NULL;
			if (tmpcache->s)
				SDL_FreeSurface(tmpcache->s);	//删除表面
			list_del(&tmpcache->list);
			Util_free(tmpcache);
			list_add(&newcache->list, &cache_head);	//加载到表头
			s_caching_fail_count++;
			if (s_caching_fail_count % 100 == 1)
				Log("Picture cache is full!");
		}
	} else {
	//已加载贴图
		newcache = pic_file[fileid].pcache[picid];
		list_del(&newcache->list);	//把这个cache从链表摘出
		list_add(&newcache->list, &cache_head);	//再插入到表头
	}
	//贴图为空，直接退出
	if (!newcache->s) {
		return 1;
	}

	if (flag & PIC_IGNORE_OFFSET) {
		xnew = x;
		ynew = y;
	} else {
		xnew = x - newcache->xoff;
		ynew = y - newcache->yoff;
	}

	BlitSurface(newcache->s, xnew, ynew, flag, value);
	return 0;
}


//得到贴图大小
int JY_GetPicSize(int fileid, int picid, int *w, int *h, int *xoff, int *yoff)
{
	TCacheNode *newcache;
	int r = Image_DrawCachedImage(fileid, picid, 
                    Video_GetScreenWidth() + 1, Video_GetScreenHeight() + 1,
                    PIC_IGNORE_OFFSET, 0);	//加载贴图到看不见的位置

	*w = 0;
	*h = 0;
	*xoff = 0;
	*yoff = 0;

	if (r != 0)
		return 1;

	newcache = pic_file[fileid].pcache[picid / 2];
	// 已有，则直接显示
	if (newcache->s) {
		*w = newcache->s->w;
		*h = newcache->s->h;
		*xoff = newcache->xoff;
		*yoff = newcache->yoff;
	}

	return 0;
}

